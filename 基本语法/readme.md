<!-- GFM-TOC -->
* [1.static关键字](#static关键字)
* [2.c++和c的区别](#区别)
* [3.c++中四种cast转换](#四种cast转换)

<!-- GFM-TOC -->

#  static关键字
## 1. 全局静态变量
在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.

**内存中的位置**:静态存储区，在整个程序运行期间一直存在。

**初始化**:未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的，除非他被显式初始化);

**作用域**:全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

## 2. 局部静态变量
在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。

**内存中的位置**:静态存储区

**初始化**:未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的，除非他 被显式初始化);

**作用域**:作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但 是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对 它进行访问，直到该函数再次被调用，并且值不变;

## 3. 静态函数
 在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同 名函数引起冲突;

**warning**:不要在头文件中声明 static 的全局函数，不要在 cpp 内声明非 static 的全局函数，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加 上 static 修饰;

## 4. 类的静态成员   

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的 成员。对多个对象来说，**静态数据成员只存储一处，供所有对象共用**

## 5. **类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此， **对静态成员的引用不需要用对象名。**

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成 员(这点非常重要)。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式:<类名>::<静态成员函数名>(<参数表>);

# 区别

设计思想上:
C++是面向对象的语言，而 C 是面向过程的结构化编程语言 语法上:
C++具有重载、继承和多态三种特性
C++相比 C，增加多许多类型安全的功能，比如强制类型转换、 C++支持范式编程，比如模板类、函数模板等

## 四种cast转换

C++中四种类型转换是:static_cast, dynamic_cast, const_cast, reinterpret_cast
**1、const_cast**
    用于将 const 变量转为非 const   
    
**2、static_cast**
    用于各种**隐式转换**，比如非 const 转 const，void*转指针等, static_cast 能用于多态向上 转化，如果向下转能成功但是不安全，结果未知;  
    
**3、dynamic_cast**
    用于**动态类型转换**。只能用于**含有虚函数的类**，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。要深入了解内部 转换的原理。
  
  向上转换:指的是子类向基类的转换
  
  向下转换:指的是基类向子类的转换
  
  它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
  
**4、reinterpret_cast**
     几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用; 
     
**5、为什么不使用C的强制转换?**
     C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查， 容易出错。
