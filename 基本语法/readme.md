<!-- GFM-TOC -->
* [基本语法](#基本语法)
   * [static关键字](#static关键字)
   * [c++和c的区别](#区别)
   * [c++中四种cast转换](#四种cast转换)
   * [指针和引用的区别](#指针和引用的区别)
   * [四个智能指针](#四个智能指针)
   * [指针和数组的区别](#指针和数组的区别)
* [类](#类)
   * [析构函数必须是虚函数](#析构函数必须是虚函数)
   * [析构函数的作用](#析构函数的作用)
   * [new/delete 与 malloc/free ](#内存分配函数 )
   * [拷贝赋值函数的形参能否进行值传递](拷贝赋值函数的形参能否进行值传递)
   * [fork,wait,exec 函数](#fork相关)
   * [stl基本组成](#stl基本组成)
   * [右值引用和左值引用](#右值引用和左值引用)
   * [双引号和尖括号区别](#双引号和尖括号区别)
* [编译与底层](#编译与底层)
   * [malloc 的原理  brk 系统调用  mmap 系统调用](#malloc的原理)
   * [cpp内存管理](#cpp内存管理)
<!-- GFM-TOC -->
[TOC]
# 基本语法
##  static关键字
### 1. 全局静态变量
在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.

**内存中的位置**:静态存储区，在整个程序运行期间一直存在。

**初始化**:未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的，除非他被显式初始化);

**作用域**:全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

### 2. 局部静态变量
在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。

**内存中的位置**:静态存储区

**初始化**:未经初始化的全局静态变量会被自动初始化为 0(自动对象的值是任意的，除非他 被显式初始化);

**作用域**:作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但 是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对 它进行访问，直到该函数再次被调用，并且值不变;

### 3. 静态函数
 在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同 名函数引起冲突;

**warning**:不要在头文件中声明 static 的全局函数，不要在 cpp 内声明非 static 的全局函数，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加 上 static 修饰;

### 4. 类的静态成员   

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的 成员。对多个对象来说，**静态数据成员只存储一处，供所有对象共用**

### 5. **类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此， **对静态成员的引用不需要用对象名。**

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成 员(这点非常重要)。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式:<类名>::<静态成员函数名>(<参数表>);

## 区别

**设计思想上:**
C++是面向对象的语言，而 C 是面向过程的结构化编程语言

**语法上:**
C++具有重载、继承和多态三种特性
C++相比 C，增加多许多类型安全的功能，比如强制类型转换、 C++支持范式编程，比如模板类、函数模板等

## 四种cast转换

C++中四种类型转换是:static_cast, dynamic_cast, const_cast, reinterpret_cast
**1、const_cast**
    用于将 const 变量转为非 const   
    
**2、static_cast**
    用于各种**隐式转换**，比如非 const 转 const，void*转指针等, static_cast 能用于多态向上 转化，如果向下转能成功但是不安全，结果未知;  
    
**3、dynamic_cast**
    用于**动态类型转换**。只能用于**含有虚函数的类**，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。要深入了解内部 转换的原理。
  
  向上转换:指的是子类向基类的转换
  
  向下转换:指的是基类向子类的转换
  
  它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。
  
**4、reinterpret_cast**
     几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用; 
     
**5、为什么不使用C的强制转换?**
     C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查， 容易出错。
     
## 指针和引用的区别
1.指针有自己的一块空间，而引用只是一个别名;

2.使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小;

3.指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象 的引用;

4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会 改变引用所指向的对象;

5.可以有 const 指针，但是没有 const 引用;

6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变; 

7.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。
 
7.指针可以有多级指针(* * p)，而引用至于一级;

8.指针和引用使用++运算符的意义不一样;

## 四个智能指针
C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是 c++11 支持，并且第一个已经被 11 弃用。

### 为什么要使用智能指针

智能指针的作用是管理一个指针，因为存在以下这种情况:申请的空间在函数结束时忘记释放，造成**内存泄漏**。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类， 当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。**所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间**。

### 1. auto_ptr(c++98 的方案，cpp11 已经抛弃)
采用所有权模式。
```
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
```

此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以 auto_ptr 的缺点是:**存在潜在的内存崩溃问题!**
### 2. unique_ptr(替换 auto_ptr)
unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以 new 创建对象后因为发生异常而忘记调用 delete”)特别有用。

采用所有权模式，
```
unique_ptr<string> p3 (new string ("auto")); //#4
unique_ptr<string> p4; //#5 
p4 = p3;//此时会报错!!
```
编译器认为 p4=p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。

另外 unique_ptr 还有更聪明的地方:当程序试图将一个 unique_ptr 赋值给另一个时，如 果源 unique_ptr 是个**临时右值**，编译器允许这么做;如果源 unique_ptr 将存在一段时间，编 译器将禁止这么做，比如:
```
unique_ptr<string> pu1(new string ("hello world")); unique_ptr<string> pu2;
pu2 = pu1; // #1 not allowed unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
``` 
其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr， 因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr 。

注:如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个 标准库函数 std::move()，让你能够将一个 unique_ptr 赋给另一个。例如:
```
unique_ptr<string> ps1, ps2; ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
    cout << *ps2 << *ps1 << endl;
```
### 3. shared_ptr
shared_ptr 实现共享式拥有概念。
多个智能指针可以指向相同对象，该对象和其相关资源 会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享， 它使用**计数机制**来表明资源被几个指针共享。可以通过成员函数 use_count()来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto_ptr, unique_ptr,weak_ptr 来构造。

当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。
shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
```
成员函数:
use_count 返回引用计数的个数
unique 返回是否是独占所有权( use_count 为 1)
swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); 
sp 与 sp.get()是等价的
```
### 4. weak_ptr
weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。

weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。

**weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题,以及内存泄漏的问题**, 如果说两个 shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为 0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转 化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。
```
class B;
class A
{
    public:
    shared_ptr<B> pb_; 
    ~A()
   {
      cout<<"A delete\n"; 
    }
};
class B
{
    public:
    shared_ptr<A> pa_; 
    ~B()
    {
       cout<<"B delete\n"; }
    };
    void fun()
    {
     shared_ptr<B> pb(new B()); 
     shared_ptr<A> pa(new A());
     pb->pa_ = pa;
     pa->pb_ = pb; 
     cout<<pb.use_count()<<endl; 
     cout<<pa.use_count()<<endl;
}
int main() 
{
  fun();
  return 0;
}
```
可以看到 fun 函数中 pa ，pb 之间互相引用，两个资源的引用计数为 2，当要跳出函数时， 智能指针 pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数 时资源没有被释放(A B 的析构函数没有被调用)，如果把其中一个改为 weak_ptr 就可以了， 我们把类 A 里面的 shared_ptr pb_; 改为 weak_ptr pb_; 运行结果如下，这样的话，资源 B 的 引用开始就只有 1，当 pb 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数 减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为 0，A 得到释放。
**注意**的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(), 我们不能这样访问，pa->pb_->print(); 英文 pb_是一个 weak_ptr，**应该先把它转化为 shared_ptr**,如:
```
shared_ptr p = pa->pb_.lock(); p->print();
```
**注意**的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(), 我们不能这样访问，pa->pb_->print(); 英文 pb_是一个 weak_ptr，**应该先把它转化为 shared_ptr**,如:shared_ptr p = pa->pb_.lock(); p->print();

**注意**的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(), 我们不能这样访问，pa->pb_->print(); 英文 pb_是一个 weak_ptr，**应该先把它转化为 shared_ptr**,如:shared_ptr p = pa->pb_.lock(); p->print();

## 指针和数组的区别 
指针 | 数组
---- | ---
 保存数据的地址 |  保存数据
间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 |  直接访问数据
 通常用于动态的数据结构   |  通常用于固定数目且数据类型相同的元素 
通过Malloc分配内存，free释放内存   |  隐式的分配和删除
通常指向匿名数据，操作匿名函数    |   自身即为数据名

# 类
## 析构函数必须是虚函数
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用 基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止**内存泄漏**。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会**浪费内存**。因此 C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

## 析构函数的作用
析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统 会自动执行析构函数。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数(即使自定义了析构 函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时 会先调用自定义的析构函数再调用合成的析构函数

类析构顺序:1)派生类本身的析构函数;2)对象成员析构函数;3)基类析构函数。

## 内存分配函数 
new/delete | malloc/fre
---- | ---
 C++的关键字 |  C 语言的库函数
   无 | 指明申请 内存空间的大小
   无  |  不会调用构造函数和析构函数
 返回的指针不用强转   | 返回的指针需要强转

## 拷贝赋值函数的形参能否进行值传递
不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时 候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

##  fork相关
父进程产生子进程使用 fork 拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进 程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf 文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。

fork 从父进程返回子进程 的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功 返回 0，错误返回-1。exec 执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

## stl基本组成
容器 迭代器 仿函数 算法 分配器 配接器

## 右值引用和左值引用
左值 |  右值 
---- | ---
能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象 |  不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象
可以寻址 | 而右值不可以
左值可以被赋值 |  右值不可以被赋值，可以用来给左值赋值
左值可变 | 右值不可变(仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变)。

## c++11新特性
特性 | 具体
---- | ---
auto关键字 |  根据初始值自动推导类型，但不能用于函数传参以及数组类型的推导
   nullptr | 指明申请 内存空间的大小
   无  |  不会调用构造函数和析构函数
 返回的指针不用强转   | 返回的指针需要强转

## 双引号和尖括号区别
编译器预处理阶段查找头文件的路径不一样。 

对于使用双引号包含的头文件，查找头文件路径的顺序为: 当前头文件目录

编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径) 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径 

对于使用尖括号包含的头文件，查找头文件的路径顺序为: 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径)

系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

# 编译与底层
##  malloc的原理
Malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc 其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。

Malloc 采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块;
同时 malloc 采用显示链表结构来管理所有的空闲块，即使用一个**双向链表**将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc 会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配;当进行内存合并时，malloc 采用**边界标记法**，根据每个块的前后块是否已经分配来决定是否进行块合并。

Malloc 在申请内存时，一般会通过**brk 或者 mmap**系统调用进行申请。
其中当申请内存**小于 128K** 时，会使用系统函数 brk 在堆区中分配;（brk指向堆的顶部）

而当申请内存**大于 128K** 时，会使用系统函数 mmap 在映射区分配。


## cpp内存管理
分区 | 内容
---- | ---
栈 |   使用栈空间存储函数的返回地址、参数、局部变量、返回值
  映射区 | 存储动态链接库以及调用 mmap 函数进行的文件映射
   堆区  |  调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存
bss 段   | 存储未初始化的全局变量和静态变量(局部+全局)，以及所有被初始化为 0 的全 局变量和静态变量
数据段  | 存储程序中已初始化的全局变量和静态变量
代码段  | 只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机 器代码
